struct Keys{
    array : [u8 * 9],
    size : i32,
}
static array_size = 32 * 512;
//multiple patterns?
struct Templates {
    //16_384 to fit maximum possible size
    array : [u8 * 16384], //suppose we store the maximum possible pattern size
    //actual number of templates
    size : i32,
    //each template length
    lengths : [i8 * 512],
}

struct Template {
    
    array : [u8 * 32], //suppose we store the maximum possible pattern size
    //actual number of template
    size : i32,
}

//single pattern :(
fn string_match_pseudoKMP(@template : Template, @maximalPatternSize: i8, ibuffer : &[u8], @ibuffer_size : i32, result_buf : &mut[i32], @block_size : i32, @chunk_size: i32) -> (){


    matchf(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,0,0,0,0,0,0,0)
    
}

fn matchf(template : Template, 
          maximalPatternSize: i8,  
          ibuffer : &[u8], 
          ibuffer_size : i32, 
          result_buf : &mut[i32], 
          block_size : i32, 
          @chunk_size: i32,
          text_index : i32,
          template_index : i32,
          t : i32,
          f : i32, //length of matched area
          ff : i32,
          headf : i32,
          headff : i32 ) -> (){
             
             compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,0,f,ff,headf,headff)
         }
fn compare(template : Template, 
         maximalPatternSize: i8,  
         ibuffer : &[u8], 
         ibuffer_size : i32, 
         result_buf : &mut[i32], 
         block_size : i32, 
         chunk_size: i32,
         text_index : i32,
         template_index : i32,
         t : i32,
         f : i32, //length of matched area
         ff : i32,
         headf : i32,
         headff : i32) -> () {

             if template_index == template.size {
                result_buf(text_index - template.size) = 1; //text index or i?
                compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,0,ff,ff,headff+1,headff+1)
             } else {
                if f == headf {
                    if text_index == ibuffer_size {
                        return()
                    } else {
                        if ibuffer(text_index) == template.array(template_index) {
                            compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index+1,template_index+1,t,f,ff+1,headf,headff)
                        } else {
                            if ff == headff {//no common prefix 
                                matchf(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index+1,0,0,f,ff,headf,headff)
                            }else { // match with prefix, i.e. f
                                compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index+1,template_index,0,ff,ff,headf + 1,headff +1)
                            }
                    }
                }
                }else { //f is length of matched area
                     if template.array(t) == template.array(template.size - (f - headf) + t) {
                         compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,template_index,t+1,f,ff,headf+1,headff) //f?
                    } else {// move head of matched area
                         compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,template_index,0,f,ff,headff+1,headff+1)
                    }
                }
             }
            //  if ibuffer(text_index) == template.array(template_index) {
                //  matchf(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index + 1,template_index + 1)
            //  } else {
                //  let r = rematch(template,template_index);
                //  if r == -1 {
                    //  matchf(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index+1,0)
                //  } else {
                    //  compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,r)
                //  }
            //  }
         }

fn rematch(template : Template, i : i32) -> i32{
    
    fn try(jp:i32, kp:i32) -> i32 {
            if kp == i {//where missmatch happened
                jp //longest prefix-suffix
            }else {
                if template.array(kp) == template.array(jp) {
                    try(jp+1,kp+1)
                }else {
                    try(0,kp-jp + 1)
                }
            }
    }

    if i == 0 {
        -1
    }else {
        try(0,1)   
    }
}

//using unified memory for results_buf for now, blocksize = 512;
//each thread proccesses area of chunk_size size;
fn string_match(@templates : Templates, @maximalPatternSize: i8 ,ibuffer : &[u8], @ibuffer_size : i32, result_buf : &mut[i32], @block_size : i32, @chunk_size: i32 ) -> () {
             //should probably padd ibuffer up to multiple of 512
             // kernel start will throw an error if grid_size is not multiple of block_size
             let grid_size : i32 = (ibuffer_size + block_size - 1) / block_size;
             print_i32(grid_size);
             print_string("\n");
             let block = (block_size, 1, 1);
             let grid = (grid_size, 1, 1);
             
             //single pattern for now // patterns will be continious arrays of chars
             with cuda(0, grid, block) {
                 // t_id is the position in the buffer
                //  let t_id = cuda_threadId_x() + cuda_blockDim_x() * cuda_blockId_x();
                 let t_id = cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x(); //dynamic :(
                 let _start = t_id * chunk_size;
                 let _end = if _start + chunk_size < ibuffer_size {_start + chunk_size} else {ibuffer_size};


                 for n in range(_start,_end) {
                     
                     let mut template_base = 0;

                     for i in unroll(0,templates.size) {

                         if i > 0 {template_base = template_base + (templates.lengths(i-1) as i32)}; 

                         let cur_length :i32 = templates.lengths(n) as i32;
                         //get rid of this if
                         if (n + cur_length) <= ibuffer_size {
                             let mut matches = 1;
                             let mut j = 0;

                             while matches == 1 && j < cur_length {

                                // think about an alternative to chunk, i.e. need to test 2 alternatives
                                // with consequtive threads access and with chunks, calculate sizes;
                                 if ibuffer(n + j) != templates.array(template_base + j) {
                                     matches = 0;
                                 }

                                 j = j + 1;
                             }

                             if matches == 1 {
                                 result_buf(n) = i;
                             }
                         } 
                     }

                 }
                //  if t_id < text_size - maximalPatternSize + 1 {
                    //  let mut m = 0;

                    //  for i in unroll(0, pattern.size) {
                         //potential thread divergence
                        // if text(t_id + i) == pattern.array(i) {
                            // m = m + 1;
                        // }

                    //  }
                    //  if m == pattern.size {
                        // result_buf(t_id) = 1;
                    //  }
                //  }
             }
             synchronize_cuda(0);
             
}

fn get42(@keys : Keys, values: &[u8], @key: u8) -> u8 {
    
    let mut res = 0;

    //swap unroll for range to see the defference
    unroll(0,9, |i| {
            
            if keys.array(i) == key {// == key
                    res = i;

    }
            });

    values(res)
    

}

fn get42_cuda(keys : Keys, values: &[u8], key: u8) -> u8 {

    let grid   = (1, 1, 1);
    let block  = (1, 1, 1);
    let device = 0;
    let buf = alloc_cuda_unified(0,sizeof[int]());
    let buf_ = bitcast[&mut[i32 * 1]](buf.data);
    buf_(0) = 0;
    let mut res = 0;
    with cuda(device, grid, block){

        let keys_shared = reserve_shared[u8](keys.size);
        for i in unroll(0,keys.size) {
            keys_shared(i) = keys.array(i);
        }

        unroll(0,keys.size, |i| {
                if keys_shared(i) == key {// == key
                    buf_(0) = i;
                    // res = i;

                }
            });
        }

    synchronize_cuda(device);
    res = buf_(0);
    release(buf);
    values(res)

}