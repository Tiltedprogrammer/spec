struct Keys{
    array : [u8 * 9],
    size : i32,
}

//multiple patterns?
struct Templates {
    //16_384 to fit maximum possible size
    array : [u8 * 16384], //suppose we store the maximum possible pattern size
    //actual number of templates
    size : i32,
    //each template length
    lengths : [i8 * 512],
}

struct Template {
    
    array : [u8 * 32], //suppose we store the maximum possible pattern size
    //actual number of template
    size : i32,
}

fn mod_length(head : i32, length : i32) -> i32 {
    if head == length {1} else {head}
}
//single pattern :(
    //add cuda
fn string_match_pseudoKMP(@template : Template, @maximalPatternSize: i8, ibuffer : &[u8], @ibuffer_size : i32, result_buf : &mut[i32], @block_size : i32, @chunk_size: i32) -> (){


    matchf(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,0,0,0,0,0,0)
    
}

fn @(?ff & ?head)move_head(ff: i32, head :i32) -> i32 {
    if ff == 1 {
        0
    } else {
        head
    }
}

fn matchf(template : Template, 
          maximalPatternSize: i8,  
          ibuffer : &[u8], 
          ibuffer_size : i32, 
          result_buf : &mut[i32], 
          block_size : i32, 
          @chunk_size: i32,
          text_index : i32,
          template_index : i32,
          @(?f)f : i32, //length of matched area
          ff : i32,
          headf : i32,
          headff : i32 ) -> (){
             
             compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,f,ff,headf,headff)
         }
fn compare(@template : Template, 
         @maximalPatternSize: i8,  
         ibuffer : &[u8], 
         ibuffer_size : i32, 
         result_buf : &mut[i32], 
         @block_size : i32, 
         @chunk_size: i32,
         text_index : i32,
         template_index : i32,
         @(?f)f : i32, //length of matched area
         ff : i32, //remembers that we have already matched region
         headf : i32,
         headff : i32) -> () {


             if template_index == template.size {
                result_buf(text_index - template.size) = 1; //text index or i?
                compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,move_head(ff,headff+1),move_head(ff,headff+1))
             }else if f == 0{
                //suffix found
                    if text_index == ibuffer_size {
                        return()
                    }else if ibuffer(text_index) == template.array(template_index) {
                            compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,headf,headff)//?
                    }else if ff == 0 {//no common prefix 
                                matchf(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index+1,0,0,0,0,0)
                    }else { // match with prefix, i.e. ff
                                compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,move_head(ff,1),move_head(ff,1))//?
                     }
                //f is the length of matched are
             }else if template.array(template_index) == template.array(headf + template_index) {
                         compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,template_index + 1,f-1,ff,headf,headff) //f?
             }else {// move head of matched area
                      compare(template,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,move_head(ff,headff+1),move_head(ff,headff+1))
              }
         }


//naive straightforward
//using unified memory for results_buf for now, blocksize = 512;
//each thread proccesses area of chunk_size size;
fn string_match(@templates : Templates, @maximalPatternSize: i8 ,ibuffer : &[u8], @ibuffer_size : i32, result_buf : &mut[i32], @block_size : i32, @chunk_size: i32 ) -> () {
             //should probably padd ibuffer up to multiple of 512
             // kernel start will throw an error if grid_size is not multiple of block_size
             let grid_size : i32 = (ibuffer_size + block_size - 1) / block_size;
             print_i32(grid_size);
             print_string("\n");
             let block = (block_size, 1, 1);
             let grid = (grid_size, 1, 1);
             
             //single pattern for now // patterns will be continious arrays of chars
             with cuda(0, grid, block) {
                 // t_id is the position in the buffer
                //  let t_id = cuda_threadId_x() + cuda_blockDim_x() * cuda_blockId_x();
                 let t_id = cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x(); //dynamic :(
                 let _start = t_id * chunk_size;
                 let _end = if _start + chunk_size < ibuffer_size {_start + chunk_size} else {ibuffer_size};


                 for n in range(_start,_end) {
                     
                     let mut template_base = 0;

                     for i in unroll(0,templates.size) {

                         if i > 0 {template_base = template_base + (templates.lengths(i-1) as i32)}; 

                         let cur_length :i32 = templates.lengths(n) as i32;
                         //get rid of this if
                         if (n + cur_length) <= ibuffer_size {
                             let mut matches = 1;
                             let mut j = 0;

                             while matches == 1 && j < cur_length {

                                // think about an alternative to chunk, i.e. need to test 2 alternatives
                                // with consequtive threads access and with chunks, calculate sizes;
                                 if ibuffer(n + j) != templates.array(template_base + j) {
                                     matches = 0;
                                 }

                                 j = j + 1;
                             }

                             if matches == 1 {
                                 result_buf(n) = i;
                             }
                         } 
                     }

                 }
                //  if t_id < text_size - maximalPatternSize + 1 {
                    //  let mut m = 0;

                    //  for i in unroll(0, pattern.size) {
                         //potential thread divergence
                        // if text(t_id + i) == pattern.array(i) {
                            // m = m + 1;
                        // }

                    //  }
                    //  if m == pattern.size {
                        // result_buf(t_id) = 1;
                    //  }
                //  }
             }
             synchronize_cuda(0);
             
}
