struct Keys{
    array : [u8 * 9],
    size : i32,
}


//multiple patterns?
struct Templates {
    //16_384 to fit maximum possible size
    array : [u8 * 16384], //suppose we store the maximum possible pattern size
    //actual number of templates
    size : i32,
    //each template length
    lengths : [i8 * 512],
}

struct Template {
    
    array : [u8 * 32], //suppose we store the maximum possible pattern size
    //actual number of template
    size : i32,
}

//single pattern :(
    //add cuda

fn string_match_pseudoKMP_nochunk(@template : Template, @maximalPatternSize: i8, ibuffer : &[u8], @ibuffer_size : i32, result_buf : &mut[i32], @block_size : i32, @chunk_size: i32) -> (){


    let block = (1024,1,1); //1024
    let grid_size : i32 = (ibuffer_size + block(0) - 1) / block(0); //thread per symbol 
    let grid = (grid_size * block(0),1,1);
    
    with cuda(0,grid,block) {

        let t_id = cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x();
        
        

        if t_id < ibuffer_size {

//for each pattern here
            matchfnc(template,
                   template.size,
                   t_id,
                   maximalPatternSize,
                   ibuffer,
                   ibuffer_size,
                   result_buf,
                   block_size,
                   chunk_size,
                   t_id,0,0,0,0); //text index

        }

        
    }
    // synchronize_cuda(0);
    
}

fn matchfnc(@(template_size > 1)template : Template,
          @template_size : i32,
          t_id : i32,
          maximalPatternSize: i8,  
          ibuffer : &[u8], 
          @ibuffer_size : i32, //right_bound if without annotation everything fails
          result_buf : &mut[i32], 
          block_size : i32, 
          chunk_size: i32,
          text_index : i32,//text_index
          @template_index : i32,
          @f : i32, //length of matched area
          @ff : i32,
          @headff : i32 ) -> (){
             
            comparenc(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf, block_size,chunk_size,text_index,0,f,ff,headff)
         }

//TODO replace compare calls
fn comparenc(@(template_size > 1)template : Template,
           @template_size : i32,  //add annotation to stop pe when size = 1, doesnt pe on some cases
           t_id : i32,
           maximalPatternSize: i8,  
           ibuffer : &[u8], 
           @ibuffer_size : i32, //right bound; if annotation here the PE aborts TODO: figure out why??!
           result_buf : &mut[i32], 
           block_size : i32, 
           chunk_size: i32,
           text_index : i32,
           @(template_size > 1)template_index : i32,
           @(template_size > 1)f : i32, //length of matched area
           @(template_size > 1)ff : i32, //remembers that we have already matched region
           @(template_size > 1)headff : i32) -> () {


             
             result_buf(t_id) = -1;
             
             if template_index == template.size {
                result_buf(t_id) = 1; //text index or i?
                // compare(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
                return()
             }else if f == 0{
                //suffix found
                //if f == 0 & ff != 0 we can match against negative information
                    if text_index == t_id + template_size {
                        return()
                    }else if ibuffer(text_index) == template.array(template_index) {
                        if ff == 0 {
                            comparenc(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,headff)
                        }else{
                            comparenc(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,0)
                        }
                    }else if ff == 0 {//no common prefix 
                                matchfnc(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index+1,0,0,0,0)
                    }else { // match with prefix, i.e. ff
                        if ff == 1 {
                            comparenc(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,0)//?
                        }else{
                            comparenc(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,1)//? execution doesnt go there if pattern size is 1, but specializer fails
                        }
                     }
                //f is the length of matched are
             }else if template.array(template_index) == template.array(headff + template_index) { //static part
                         if f == 1 && ff != 0 && template.array(template_index+1) == template.array(headff + ff){
                            comparenc(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
                         }else {
                            comparenc(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,template_index + 1,f-1,ff,headff)
                         } //f?
             }else {// move head of matched area
                      comparenc(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
              }
         }


fn string_match_pseudoKMP(@template : Template, @maximalPatternSize: i8, ibuffer : &[u8], @ibuffer_size : i32, result_buf : &mut[i32], @block_size : i32, @chunk_size: i32) -> (){


    let block = (1024,1,1); //1024
    let chunk = 256; //experiment with it if eq 4 compilation fails
    let grid_size : i32 = (((ibuffer_size + chunk - 1) / chunk) + block(0) - 1) / block(0); //1 thread takes 256 byte piece 
    let grid = (grid_size * block(0),1,1);
    
    with cuda(0,grid,block) {

        let t_id = cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x();

        let left_bound = t_id * chunk;
        let mut right_bound = left_bound + chunk + template.size-1; //right not included
        
        if right_bound >= ibuffer_size {
            right_bound = ibuffer_size;
        }

        if left_bound < ibuffer_size {

//for each pattern here
            matchf(template,
                   template.size,
                   maximalPatternSize,
                   ibuffer,
                   ibuffer_size,
                   left_bound,
                   right_bound,
                   result_buf,
                   block_size,
                   chunk,
                   left_bound,0,0,0,0); //text index

        }

        
    }
    // synchronize_cuda(0);
    
}

fn matchf(@(template_size > 1)template : Template,
          @template_size : i32,
          maximalPatternSize: i8,  
          ibuffer : &[u8], 
          @ibuffer_size : i32, //right_bound if without annotation everything fails
          left_bound : i32,
          right_bound : i32,
          result_buf : &mut[i32], 
          block_size : i32, 
          chunk_size: i32,
          text_index : i32,//text_index
          @template_index : i32,
          @f : i32, //length of matched area
          @ff : i32,
          @headff : i32 ) -> (){
             
            compare(template,template_size,maximalPatternSize,ibuffer,right_bound,left_bound,right_bound,result_buf, block_size,chunk_size,text_index,0,f,ff,headff)
         }

//TODO replace compare calls
fn compare(@(template_size > 1)template : Template,
           @template_size : i32,  //add annotation to stop pe when size = 1, doesnt pe on some cases
           maximalPatternSize: i8,  
           ibuffer : &[u8], 
           @ibuffer_size : i32, //right bound; if annotation here the PE aborts TODO: figure out why??!
           left_bound : i32,
           right_bound : i32,
           result_buf : &mut[i32], 
           block_size : i32, 
           chunk_size: i32,
           text_index : i32,
           @(template_size > 1)template_index : i32,
           @(template_size > 1)f : i32, //length of matched area
           @(template_size > 1)ff : i32, //remembers that we have already matched region
           @(template_size > 1)headff : i32) -> () {


             if(text_index < left_bound + chunk_size){
                result_buf(text_index) = -1;
             }
             
             if template_index == template.size {
                result_buf(text_index - template.size) = 1; //text index or i?
                compare(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
             }else if f == 0{
                //suffix found
                //if f == 0 & ff != 0 we can match against negative information
                    if text_index == ibuffer_size {
                        return()
                    }else if ibuffer(text_index) == template.array(template_index) {
                        if ff == 0 {
                            compare(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,headff)
                        }else{
                            compare(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,0)
                        }
                    }else if ff == 0 {//no common prefix 
                                matchf(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index+1,0,0,0,0)
                    }else { // match with prefix, i.e. ff
                        if ff == 1 {
                            compare(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,0)//?
                        }else{
                            compare(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,1)//? execution doesnt go there if pattern size is 1, but specializer fails
                        }
                     }
                //f is the length of matched are
             }else if template.array(template_index) == template.array(headff + template_index) { //static part
                         if f == 1 && ff != 0 && template.array(template_index+1) == template.array(headff + ff){
                            compare(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
                         }else {
                            compare(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,template_index + 1,f-1,ff,headff)
                         } //f?
             }else {// move head of matched area
                      compare(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
              }
         }




fn string_match_pseudoKMP_pointer(@template : &[u8],t_size : i32, @maximalPatternSize: i8, ibuffer : &[u8], @ibuffer_size : i32, result_buf : &mut[i32], @block_size : i32, @chunk_size: i32) -> (){


    let block = (1024,1,1); //1024
    let chunk = 256; //experiment with it
    let grid_size : i32 = (ibuffer_size + block(0)*chunk - 1) / block(0)*chunk; //1 thread takes 256 byte piece 
    let grid = (grid_size * block(0),1,1);
    
    with cuda(0,grid,block) {

        let t_id = cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x();

        let left_bound = t_id * chunk;
        let mut right_bound = left_bound + chunk + t_size-1; //right not included
        
        if right_bound >= ibuffer_size {
            right_bound = ibuffer_size;
        }

        if left_bound < ibuffer_size {

//for each pattern here
            matchfps(template,
                   t_size,
                   maximalPatternSize,
                   ibuffer,
                   ibuffer_size,
                   left_bound,
                   right_bound,
                   result_buf,
                   block_size,
                   chunk,
                   left_bound,0,0,0,0); //text index

        }

        
    }
    // synchronize_cuda(0);
    
}

fn matchfps(@(template_size > 1)template : &[u8],
          @template_size : i32,
          maximalPatternSize: i8,  
          ibuffer : &[u8], 
          @ibuffer_size : i32, //right_bound if without annotation everything fails
          left_bound : i32,
          right_bound : i32,
          result_buf : &mut[i32], 
          block_size : i32, 
          chunk_size: i32,
          text_index : i32,//text_index
          @template_index : i32,
          @f : i32, //length of matched area
          @ff : i32,
          @headff : i32 ) -> (){
             
            compareps(template,template_size,maximalPatternSize,ibuffer,right_bound,left_bound,right_bound,result_buf, block_size,chunk_size,text_index,0,f,ff,headff)
         }

//TODO replace compare calls
fn compareps(@(template_size > 1)template : &[u8],
           @template_size : i32,  //add annotation to stop pe when size = 1, doesnt pe on some cases
           maximalPatternSize: i8,  
           ibuffer : &[u8], 
           @ibuffer_size : i32, //right bound; if annotation here the PE aborts TODO: figure out why??!
           left_bound : i32,
           right_bound : i32,
           result_buf : &mut[i32], 
           block_size : i32, 
           chunk_size: i32,
           text_index : i32,
           @(template_size > 1)template_index : i32,
           @(template_size > 1)f : i32, //length of matched area
           @(template_size > 1)ff : i32, //remembers that we have already matched region
           @(template_size > 1)headff : i32) -> () {


             if(text_index < left_bound + chunk_size){
                result_buf(text_index) = -1;
             }
             
             if template_index == template_size {
                result_buf(text_index - template_size) = 1; //text index or i?
                compareps(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
             }else if f == 0{
                //suffix found
                //if f == 0 & ff != 0 we can match against negative information
                    if text_index == ibuffer_size {
                        return()
                    }else if ibuffer(text_index) == template(template_index) {
                        if ff == 0 {
                            compareps(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,headff)
                        }else{
                            compareps(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,0)
                        }
                    }else if ff == 0 {//no common prefix 
                                matchfps(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index+1,0,0,0,0)
                    }else { // match with prefix, i.e. ff
                        if ff == 1 {
                            compareps(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,0)//?
                        }else{
                            compareps(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,1)//? execution doesnt go there if pattern size is 1, but specializer fails
                        }
                     }
                //f is the length of matched are
             }else if template(template_index) == template(headff + template_index) { //static part
                         if f == 1 && ff != 0 && template(template_index+1) == template(headff + ff){
                            compareps(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
                         }else {
                            compareps(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,template_index + 1,f-1,ff,headff)
                         } //f?
             }else {// move head of matched area
                      compareps(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
              }
         }

fn string_match_pseudoKMP_pointer_multiple(@templates : &[u8], @t_sizes: &[i32],@t_num :i32,@t_max:i32, ibuffer : &[u8], @ibuffer_size : i32, result_buf : &mut[i32], @block_size : i32, @chunk_size: i32) -> (){


    let block = (1,1,1); //1024 and 256 doesn't compile dunno why and produces strange results
    let chunk = 256; //experiment with it ???
    let grid_size : i32 = (ibuffer_size + block(0)*chunk - 1) / block(0)*chunk; //1 thread takes 256 byte piece 
    let grid = (grid_size * block(0),1,1);
    
    with cuda(0,grid,block) {

        let t_id = cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x();

        let left_bound = t_id * chunk;
        let mut right_bound = left_bound + chunk + t_max-1; //right not included
        
        if right_bound >= ibuffer_size {
            right_bound = ibuffer_size;
        }

        if left_bound < ibuffer_size {

//for each pattern here
            // for i in unroll(0,t_num){
            //TODO: maxpattern size + read&write to different ranges
            matchfp(templates,
                        t_sizes(0),
                        3, //try to search 2nd pattern
                        ibuffer,
                        ibuffer_size,
                        left_bound,
                        right_bound,
                        result_buf,
                        block_size,
                        chunk,
                        left_bound,0,0,0,0); //text index

            // }
                            
        }

        
    }
    // synchronize_cuda(0);
    
}

fn matchfp(@(template_size > 1)templates : &[u8],
          @template_size : i32,
          @t_offset :i32,  
          ibuffer : &[u8], 
          @ibuffer_size : i32, //right_bound if without annotation everything fails
          left_bound : i32,
          right_bound : i32,
          result_buf : &mut[i32], 
          block_size : i32, 
          chunk_size: i32,
          text_index : i32,//text_index
          @template_index : i32,
          @f : i32, //length of matched area
          @ff : i32,
          @headff : i32 ) -> (){
             
            comparep(templates,template_size,t_offset,ibuffer,right_bound,left_bound,right_bound,result_buf, block_size,chunk_size,text_index,t_offset,f,ff,headff)//offset for templates
     
         }

//TODO replace compare calls
fn comparep(@(template_size > 1)template : &[u8],
           @template_size : i32,
           @t_offset : i32,  //add annotation to stop pe when size = 1, doesnt pe on some cases  
           ibuffer : &[u8], 
           @ibuffer_size : i32, //right bound; if annotation here the PE aborts TODO: figure out why??!
           left_bound : i32,
           right_bound : i32,
           result_buf : &mut[i32], 
           block_size : i32, 
           chunk_size: i32,
           text_index : i32,
           @(template_size > 1)template_index : i32,
           @(template_size > 1)f : i32, //length of matched area
           @(template_size > 1)ff : i32, //remembers that we have already matched region
           @(template_size > 1)headff : i32) -> () {


             if(text_index < left_bound + chunk_size){
                result_buf(text_index) = -1;
             }
                         
             if template_index == template_size + t_offset {
                result_buf(text_index - template_size) = 1; //if text_index < offset + size
                comparep(template,template_size,t_offset,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,t_offset,ff-1,ff-1,headff+1)
             }else if f == 0{
                // suffix found
                // if f == 0 & ff != 0 we can match against negative information
                    if text_index == ibuffer_size {
                        return()
                    }else if ibuffer(text_index) == template(template_index) {
                        if ff == 0 {
                            comparep(template,template_size,t_offset,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,headff)
                        }else{
                            comparep(template,template_size,t_offset,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,0)
                        }
                    }else if ff == 0 {//no common prefix 
                                matchfp(template,template_size,t_offset,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index+1,0,0,0,0)
                    }else { // match with prefix, i.e. ff
                        if ff == 1 {
                            comparep(template,template_size,t_offset,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,t_offset,ff-1,ff-1,0)//?
                        }else{
                            comparep(template,template_size,t_offset,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,t_offset,ff-1,ff-1,1)//? execution doesnt go there if pattern size is 1, but specializer fails
                        }
                     }
                //f is the length of matched are
             }else if template(template_index) == template(headff + template_index) { //static part
                         if f == 1 && ff != 0 && template(template_index+1) == template(headff + ff){
                            comparep(template,template_size,t_offset,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,t_offset,ff-1,ff-1,headff+1)
                         }else {
                            comparep(template,template_size,t_offset,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,template_index + 1,f-1,ff,headff)
                         } //f?
             }else {// move head of matched area
                      comparep(template,template_size,t_offset,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,t_offset,ff-1,ff-1,headff+1)
              }
         }


//naive straightforward;
//using unified memory for results_buf for now, blocksize = 512;
//each thread proccesses area of chunk_size size;
//template here should be in device memory or to be a struct;
fn string_match(@template : Template, @template_size: i32 ,@maximalPatternSize: i8, ibuffer : &[u8], @ibuffer_size : i32, result_buf : &mut[i32], @block_size : i32, @chunk_size: i32, @nochunk : i32 ) -> () {
             
            if nochunk == 1 {

                let block = (1024,1,1);

                let grid_size : i32 = (ibuffer_size + block(0) - 1) / block(0);
            

                let grid = (block(0) * grid_size, 1, 1); //grid is the overall number of threads;
             
                
                with cuda(0, grid, block) {
                    
                    let t_id = cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x(); //dynamic :(;
                    
                    if t_id < ibuffer_size {
                        
                        let mut matched : i8 = 1i8;
                        result_buf(t_id) = -1;

                        for i in unroll(0,template_size){
                            if ibuffer(t_id + i) != template.array(i) {
                                matched = -1i8;
                                break()
                            }
                        }
                        
                        if matched == 1i8 {
                            result_buf(t_id) = 1;
                        }
                     

                    }
                }
             }else {

                let block = (1024, 1, 1); // block is threads per block
                let grid_size : i32 = (((ibuffer_size + chunk_size - 1) / chunk_size) + block(0) - 1) / block(0);
             
                let grid = (block(0) * grid_size, 1, 1); //grid is the overall number of threads
             
                //single pattern for now // patterns will be continious arrays of chars;
                with cuda(0, grid, block) {
                    // t_id is the position in the buffer;
                    //  let t_id = cuda_threadId_x() + cuda_blockDim_x() * cuda_blockId_x();
                    let t_id = cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x();
                    let left_bound = t_id * chunk_size; //dynamic :(
                    if left_bound < ibuffer_size {
                        for i in range(0,chunk_size){
                            result_buf(left_bound + i) = -1;
                            let mut matched = 1;

                            for j in unroll(0,template_size) {
                                if ibuffer(left_bound + i + j) != template.array(j){
                                    matched = -1;
                                }
                            }

                            if matched == 1 {
                                result_buf(left_bound+i) = 1;
                            }

                        }
                    }

                }
             }
            //  synchronize_cuda(0);
             
}

// prefixFun s k i p         | k > i = p
                        //   | isPrefix s k 0 (i-k+1) = prefixFun s (k+1) i k
                        //   | otherwise = prefixFun s (k+1) i p

// isPrefix s k j jk | j == k = True
                //   | (s !! j == s !! jk) = (isPrefix s k (j+1) (jk+1))
                //   | otherwise = False


fn prefix_function(@template : &[u8], @index : i32) -> i32{  //pe here ok;

    fn is_prefix(@k_: i32) -> bool {
        
        let mut isPrefix = true;
        
        for i in unroll(0,k_){
            if template(i) != template(index - k_ + 1 + i) {
                isPrefix = false;
            }
        }
        isPrefix
    }

    let mut res = 0;
    for k in unroll(0,index + 1) {
        if is_prefix(k) {
            res = k;
        }
    }

    res
}

fn match_kmp(@template : &[u8], @t_size: i32 ,@maximalPatternSize: i8, ibuffer : &[u8], @ibuffer_size : i32, result_buf : &mut[i32], @block_size : i32, @chunk_size: i32, @nochunk : i32) -> (){

    if nochunk == 0 {
        let block = (1024,1,1); //1024
        let chunk = chunk_size; //experiment with it
        let grid_size : i32 = (((ibuffer_size + chunk - 1) / chunk) + block(0) - 1) / block(0);
        let grid = (grid_size * block(0),1,1);
    
        with cuda(0,grid,block) {

            let t_id = cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x();

            let left_bound = t_id * chunk;
            let mut right_bound = left_bound + chunk + t_size-1; //right not included
        
            if right_bound >= ibuffer_size {
                right_bound = ibuffer_size;
            }

            if left_bound < ibuffer_size {

                kmp(template,t_size,left_bound,left_bound,right_bound,ibuffer,result_buf,chunk,0)
            }
        }
    }else { //nochunk

        let block = (1024,1,1);
        let grid_size = (ibuffer_size + block(0) - 1) / block(0);
        let grid = (grid_size * block(0),1,1);

        with cuda(0,grid,block) {

            let t_id = cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x();

            if t_id < ibuffer_size {
                kmp_nc(template,t_size,t_id,ibuffer,result_buf)
            }
        }





    }
}


// let mut ams = 0; // ams;

    // for i in range(left_bound,right_bound) {;
        
        // if (i < left_bound + chunk_size) {;

            // result_buf(i) = -1;

        // };

        // while ams > 0 && template(ams) != ibuffer(i) { //missmatch at i pos;
            // ams = prefix_function(template,ams-1);
        // };
        
        // if ibuffer(i) == template(ams){;
            // ams = ams + 1;
        // };

        // if ams == template_size {;

            // result_buf(i - template_size + 1) = 1;
            // ams = prefix_function(template,ams-1);
        
        // };
        
    // };

fn kmp(@template : &[u8], @template_size: i32, text_index : i32, left_bound : i32, right_bound : i32, ibuffer : &[u8], result_buf : &mut[i32], @chunk_size : i32, @ams : i32) -> () {
    
    fn prefix_function(@index : i32) -> i32{  //pe here ok;

        fn is_prefix(@k_: i32) -> bool {
        
            let mut isPrefix = true;
        
            for i in unroll(0,k_){
                if template(i) != template(index - k_ + 1 + i) {
                    isPrefix = false;
                }
            }
            isPrefix
        }

        let mut res = 0;
        for k in unroll(0,index + 1) {
            if is_prefix(k) {
                res = k;
            }
        }

        res
    }

    if text_index < left_bound + chunk_size {
        result_buf(text_index) = -1;
    }


    if ams == template_size {
        
        result_buf(text_index - template_size) = 1;
        kmp(template,template_size,text_index,left_bound,right_bound,ibuffer,result_buf,chunk_size, prefix_function(ams - 1))
    
    }else if text_index == right_bound {
        return()
    }else if ams > 0 && template(ams) != ibuffer(text_index){
        kmp(template,template_size,text_index,left_bound,right_bound,ibuffer,result_buf, chunk_size, prefix_function(ams - 1))
    }

    else if template(ams) == ibuffer(text_index){
        
        kmp(template,template_size,text_index + 1,left_bound,right_bound,ibuffer,result_buf,chunk_size,ams + 1)
    
    }else{
        
        kmp(template,template_size,text_index+1,left_bound,right_bound,ibuffer,result_buf,chunk_size, 0)
    
    }

}

fn kmp_nc(@template : &[u8], @template_size: i32, @t_id : i32, ibuffer : &[u8], result_buf : &mut[i32]) -> (){
    
    fn prefix_function(@index : i32) -> i32{  //pe here ok;

        fn is_prefix(@k_: i32) -> bool {
        
            let mut isPrefix = true;
        
            for i in unroll(0,k_){
                if template(i) != template(index - k_ + 1 + i) {
                    isPrefix = false;
                }
            }
            isPrefix
        }

        let mut res = 0;
        for k in unroll(0,index + 1) {
            if is_prefix(k) {
                res = k;
            }
        }

        res
    }

    let mut ams = 0; // ams

    for i in unroll(0,template_size) {
        
        result_buf(t_id) = -1;

        while ams > 0 && template(ams) != ibuffer(t_id+i) { //missmatch at i pos
            ams = prefix_function(ams-1);
        }
        
        if ibuffer(t_id + i) == template(ams){
            ams = ams + 1;
        }

        if ams == template_size {

            result_buf(t_id) = 1;
            ams = prefix_function(ams-1);
        
        }
        
    }

}



fn string_match_pseudoKMP_nochunk_nope(template : Template, maximalPatternSize: i8, ibuffer : &[u8], ibuffer_size : i32, result_buf : &mut[i32], block_size : i32, chunk_size: i32) -> (){


    let block = (1024,1,1); //1024
    let grid_size : i32 = (ibuffer_size + block(0) - 1) / block(0); //thread per symbol 
    let grid = (grid_size * block(0),1,1);
    
    with cuda(0,grid,block) {

        let t_id = cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x();
        
        

        if t_id < ibuffer_size {

//for each pattern here
            matchfnc_no(template,
                   template.size,
                   t_id,
                   maximalPatternSize,
                   ibuffer,
                   ibuffer_size,
                   result_buf,
                   block_size,
                   chunk_size,
                   t_id,0,0,0,0); //text index

        }

        
    }
    // synchronize_cuda(0);
    
}

fn matchfnc_no(template : Template,
          template_size : i32,
          t_id : i32,
          maximalPatternSize: i8,  
          ibuffer : &[u8], 
          ibuffer_size : i32, //right_bound if without annotation everything fails
          result_buf : &mut[i32], 
          block_size : i32, 
          chunk_size: i32,
          text_index : i32,//text_index
          template_index : i32,
          f : i32, //length of matched area
          ff : i32,
          headff : i32 ) -> (){
             
            comparenc_no(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf, block_size,chunk_size,text_index,0,f,ff,headff)
         }

//TODO replace compare calls
fn comparenc_no(template : Template,
           template_size : i32,  //add annotation to stop pe when size = 1, doesnt pe on some cases
           t_id : i32,
           maximalPatternSize: i8,  
           ibuffer : &[u8], 
           ibuffer_size : i32, //right bound; if annotation here the PE aborts TODO: figure out why??!
           result_buf : &mut[i32], 
           block_size : i32, 
           chunk_size: i32,
           text_index : i32,
           template_index : i32,
           f : i32, //length of matched area
           ff : i32, //remembers that we have already matched region
           headff : i32) -> () {


             
             result_buf(t_id) = -1;
             
             if template_index == template.size {
                result_buf(t_id) = 1; //text index or i?
                // compare(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
                return()
             }else if f == 0{
                //suffix found
                //if f == 0 & ff != 0 we can match against negative information
                    if text_index == t_id + template_size {
                        return()
                    }else if ibuffer(text_index) == template.array(template_index) {
                        if ff == 0 {
                            comparenc_no(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,headff)
                        }else{
                            comparenc_no(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,0)
                        }
                    }else if ff == 0 {//no common prefix 
                                matchfnc_no(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index+1,0,0,0,0)
                    }else { // match with prefix, i.e. ff
                        if ff == 1 {
                            comparenc_no(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,0)//?
                        }else{
                            comparenc_no(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,1)//? execution doesnt go there if pattern size is 1, but specializer fails
                        }
                     }
                //f is the length of matched are
             }else if template.array(template_index) == template.array(headff + template_index) { //static part
                         if f == 1 && ff != 0 && template.array(template_index+1) == template.array(headff + ff){
                            comparenc_no(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
                         }else {
                            comparenc_no(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,template_index + 1,f-1,ff,headff)
                         } //f?
             }else {// move head of matched area
                      comparenc_no(template,template_size,t_id,maximalPatternSize,ibuffer,ibuffer_size,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
              }
         }


fn string_match_pseudoKMP_nope(template : Template, maximalPatternSize: i8, ibuffer : &[u8], ibuffer_size : i32, result_buf : &mut[i32], block_size : i32, chunk_size: i32) -> (){


    let block = (1024,1,1); //1024
    let chunk = 256; //experiment with it if eq 4 compilation fails
    let grid_size : i32 = (((ibuffer_size + chunk - 1) / chunk) + block(0) - 1) / block(0); //1 thread takes 256 byte piece 
    let grid = (grid_size * block(0),1,1);
    
    with cuda(0,grid,block) {

        let t_id = cuda_threadIdx_x() + cuda_blockDim_x() * cuda_blockIdx_x();

        let left_bound = t_id * chunk;
        let mut right_bound = left_bound + chunk + template.size-1; //right not included
        
        if right_bound >= ibuffer_size {
            right_bound = ibuffer_size;
        }

        if left_bound < ibuffer_size {

//for each pattern here
            matchf_no(template,
                   template.size,
                   maximalPatternSize,
                   ibuffer,
                   ibuffer_size,
                   left_bound,
                   right_bound,
                   result_buf,
                   block_size,
                   chunk,
                   left_bound,0,0,0,0); //text index

        }

        
    }
    // synchronize_cuda(0);
    
}

fn matchf_no(template : Template,
          template_size : i32,
          maximalPatternSize: i8,  
          ibuffer : &[u8], 
          ibuffer_size : i32, //right_bound if without annotation everything fails
          left_bound : i32,
          right_bound : i32,
          result_buf : &mut[i32], 
          block_size : i32, 
          chunk_size: i32,
          text_index : i32,//text_index
          template_index : i32,
          f : i32, //length of matched area
          ff : i32,
          headff : i32 ) -> (){
             
            compare_no(template,template_size,maximalPatternSize,ibuffer,right_bound,left_bound,right_bound,result_buf, block_size,chunk_size,text_index,0,f,ff,headff)
         }

//TODO replace compare calls
fn compare_no(template : Template,
           template_size : i32,  //add annotation to stop pe when size = 1, doesnt pe on some cases
           maximalPatternSize: i8,  
           ibuffer : &[u8], 
           ibuffer_size : i32, //right bound; if annotation here the PE aborts TODO: figure out why??!
           left_bound : i32,
           right_bound : i32,
           result_buf : &mut[i32], 
           block_size : i32, 
           chunk_size: i32,
           text_index : i32,
           template_index : i32,
           f : i32, //length of matched area
           ff : i32, //remembers that we have already matched region
           headff : i32) -> () {


             if(text_index < left_bound + chunk_size){
                result_buf(text_index) = -1;
             }
             
             if template_index == template.size {
                result_buf(text_index - template.size) = 1; //text index or i?
                compare_no(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
             }else if f == 0{
                //suffix found
                //if f == 0 & ff != 0 we can match against negative information
                    if text_index == ibuffer_size {
                        return()
                    }else if ibuffer(text_index) == template.array(template_index) {
                        if ff == 0 {
                            compare_no(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,headff)
                        }else{
                            compare_no(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index+1,template_index + 1,f,ff+1,0)
                        }
                    }else if ff == 0 {//no common prefix 
                                matchf_no(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index+1,0,0,0,0)
                    }else { // match with prefix, i.e. ff
                        if ff == 1 {
                            compare_no(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,0)//?
                        }else{
                            compare_no(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,1)//? execution doesnt go there if pattern size is 1, but specializer fails
                        }
                     }
                //f is the length of matched are
             }else if template.array(template_index) == template.array(headff + template_index) { //static part
                         if f == 1 && ff != 0 && template.array(template_index+1) == template.array(headff + ff){
                            compare_no(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
                         }else {
                            compare_no(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,template_index + 1,f-1,ff,headff)
                         } //f?
             }else {// move head of matched area
                      compare_no(template,template_size,maximalPatternSize,ibuffer,ibuffer_size,left_bound,right_bound,result_buf,block_size,chunk_size,text_index,0,ff-1,ff-1,headff+1)
              }
         }
